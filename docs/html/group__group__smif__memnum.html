<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSOC E8XXGO Device Support Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSOC E8XXGO Device Support Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__smif__memnum.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SMIFNUM (Serial MemoryNum Interface)<div class="ingroups"><a class="el" href="group__group__pdl__top.html">PDL API Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<h1><a class="anchor" id="group_smif_section_secure_aware"></a>
Secure Aware SMIF</h1>
<p >Some SMIF APIs are marked as Secure Aware. This means that if the SMIF is marked as a secure resource in the Peripheral Protection Controller (PPC) and these APIs are called from a non-secure CPU state, the PDL will submit a request to the Secure Request Framework (SRF) middleware to transition to a secure CPU state to perform the operation. From the application's perspective, the API will behave the same whether it is called from a secure or non-secure CPU state albeit slower.</p>
<p >This functionality is automatically enabled on devices with ARM TrustZone processors. To disable, set the DEFINE+=CY_PDL_ENABLE_SECURE_AWARE_SMIF=0 in the application Makefile.</p>
<p >For more information on Secure Aware PDL behavior, see <a class="el" href="group__group__pdl__srf.html#group_pdl_srf_general">Secure Aware PDL</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structcy__stc__smif__mem__context__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a></td></tr>
<tr class="memdesc:structcy__stc__smif__mem__context__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SMIF Device internal context data.  <a href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__smif__mem__context__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcy__stc__smif__hyb__sectors__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__hyb__sectors__info__t">cy_stc_smif_hyb_sectors_info_t</a></td></tr>
<tr class="memdesc:structcy__stc__smif__hyb__sectors__info__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure specifies data relevant to the non-secure side relative to hybrid sectors.  <a href="group__group__smif__memnum.html#structcy__stc__smif__hyb__sectors__info__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__smif__hyb__sectors__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structcy__stc__smif__mem__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__info__t">cy_stc_smif_mem_info_t</a></td></tr>
<tr class="memdesc:structcy__stc__smif__mem__info__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This SMIF memory info structure is used to store the memory information that are useful to the non-secure side in Secure-Aware environments.  <a href="group__group__smif__memnum.html#structcy__stc__smif__mem__info__t">More...</a><br /></td></tr>
<tr class="separator:structcy__stc__smif__mem__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga35b5de62ab95ba5d9e4123e7a0bc1cba"><td class="memItemLeft" align="right" valign="top"><a id="ga35b5de62ab95ba5d9e4123e7a0bc1cba" name="ga35b5de62ab95ba5d9e4123e7a0bc1cba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SMIF_MAX_HYBRID_REGION</b>&#160;&#160;&#160;(5U)</td></tr>
<tr class="memdesc:ga35b5de62ab95ba5d9e4123e7a0bc1cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of hybrid regions in the supported external memories. <br /></td></tr>
<tr class="separator:ga35b5de62ab95ba5d9e4123e7a0bc1cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b8b22262145ab18c69668352184ca4"><td class="memItemLeft" align="right" valign="top"><a id="ga30b8b22262145ab18c69668352184ca4" name="ga30b8b22262145ab18c69668352184ca4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SMIF_SUB_BLOCK_0</b>&#160;&#160;&#160;(0UL)</td></tr>
<tr class="memdesc:ga30b8b22262145ab18c69668352184ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMIF sub-block 0. <br /></td></tr>
<tr class="separator:ga30b8b22262145ab18c69668352184ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7590fb5eca601518d96abbba40ec5b7a"><td class="memItemLeft" align="right" valign="top"><a id="ga7590fb5eca601518d96abbba40ec5b7a" name="ga7590fb5eca601518d96abbba40ec5b7a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SMIF_SUB_BLOCK_1</b>&#160;&#160;&#160;(1UL)</td></tr>
<tr class="memdesc:ga7590fb5eca601518d96abbba40ec5b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMIF sub-block 1. <br /></td></tr>
<tr class="separator:ga7590fb5eca601518d96abbba40ec5b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad603f16802bad1881c2f9d4d292b7b3b"><td class="memItemLeft" align="right" valign="top"><a id="gad603f16802bad1881c2f9d4d292b7b3b" name="gad603f16802bad1881c2f9d4d292b7b3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SMIF_FLAG_SPI_DEVICE</b>&#160;&#160;&#160;(1UL)</td></tr>
<tr class="memdesc:gad603f16802bad1881c2f9d4d292b7b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMIF flag to identify regular SPI devices. <br /></td></tr>
<tr class="separator:gad603f16802bad1881c2f9d4d292b7b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95952f335102b6a61fb21f700fbef837"><td class="memItemLeft" align="right" valign="top"><a id="ga95952f335102b6a61fb21f700fbef837" name="ga95952f335102b6a61fb21f700fbef837"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CY_SMIF_FLAG_HYPERBUS_DEVICE</b>&#160;&#160;&#160;(2UL)</td></tr>
<tr class="memdesc:ga95952f335102b6a61fb21f700fbef837"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMIF flag to identify HyperBus devices. <br /></td></tr>
<tr class="separator:ga95952f335102b6a61fb21f700fbef837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga25c6d89bbe80347e2869ea4f9c7e3e3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#ga25c6d89bbe80347e2869ea4f9c7e3e3b">Cy_SMIF_MemNumInit</a> (SMIF_Type *base, <a class="el" href="group__group__smif__data__structures__memslot.html#structcy__stc__smif__block__config__t">cy_stc_smif_block_config_t</a> const *blockConfig, <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context)</td></tr>
<tr class="memdesc:ga25c6d89bbe80347e2869ea4f9c7e3e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the slots of the memory device in the SMIF configuration.  <a href="group__group__smif__memnum.html#ga25c6d89bbe80347e2869ea4f9c7e3e3b">More...</a><br /></td></tr>
<tr class="separator:ga25c6d89bbe80347e2869ea4f9c7e3e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4db2735b96e247a8181a9fb889160d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#gab4db2735b96e247a8181a9fb889160d1">Cy_SMIF_MemNumGetInfo</a> (const <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__info__t">cy_stc_smif_mem_info_t</a> *memNumInfo)</td></tr>
<tr class="memdesc:gab4db2735b96e247a8181a9fb889160d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is to be called from the non secure partition in trustzone devices to gather all information about the memory size, erase and program size to be used in subsequent MemNum calls instead of polling the secure partition repeatedly for the information.  <a href="group__group__smif__memnum.html#gab4db2735b96e247a8181a9fb889160d1">More...</a><br /></td></tr>
<tr class="separator:gab4db2735b96e247a8181a9fb889160d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8e79e0dac326c8c2bb3f9eaddf621e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#ga7b8e79e0dac326c8c2bb3f9eaddf621e">Cy_SMIF_MemNumRead</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, uint32_t address, uint8_t rxBuffer[], uint32_t length)</td></tr>
<tr class="memdesc:ga7b8e79e0dac326c8c2bb3f9eaddf621e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the external memory and blocks until the read transfer is complete or a timeout occurs.  <a href="group__group__smif__memnum.html#ga7b8e79e0dac326c8c2bb3f9eaddf621e">More...</a><br /></td></tr>
<tr class="separator:ga7b8e79e0dac326c8c2bb3f9eaddf621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea43c03ea5b9d860dffb991888a929d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#gaea43c03ea5b9d860dffb991888a929d4">Cy_SMIF_MemNumWrite</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, uint32_t address, uint8_t const txBuffer[], uint32_t length)</td></tr>
<tr class="memdesc:gaea43c03ea5b9d860dffb991888a929d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes data to the external memory.  <a href="group__group__smif__memnum.html#gaea43c03ea5b9d860dffb991888a929d4">More...</a><br /></td></tr>
<tr class="separator:gaea43c03ea5b9d860dffb991888a929d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c213ddaa8165c67bb0b02bd3d2b9268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#ga5c213ddaa8165c67bb0b02bd3d2b9268">Cy_SMIF_MemNumEraseSector</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, uint32_t address, uint32_t length)</td></tr>
<tr class="memdesc:ga5c213ddaa8165c67bb0b02bd3d2b9268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a block/sector of the external memory.  <a href="group__group__smif__memnum.html#ga5c213ddaa8165c67bb0b02bd3d2b9268">More...</a><br /></td></tr>
<tr class="separator:ga5c213ddaa8165c67bb0b02bd3d2b9268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa64f50292063e65833c72f1deaf27f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#gafa64f50292063e65833c72f1deaf27f2">Cy_SMIF_MemNumEraseChip</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum)</td></tr>
<tr class="memdesc:gafa64f50292063e65833c72f1deaf27f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the entire chip of the external memory.  <a href="group__group__smif__memnum.html#gafa64f50292063e65833c72f1deaf27f2">More...</a><br /></td></tr>
<tr class="separator:gafa64f50292063e65833c72f1deaf27f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bffdee7e2b8c7404b746b4b7de1f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#ga20bffdee7e2b8c7404b746b4b7de1f90">Cy_SMIF_MemNumHyperBusRead</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, uint32_t address, uint8_t rxBuffer[], uint32_t length)</td></tr>
<tr class="memdesc:ga20bffdee7e2b8c7404b746b4b7de1f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads data from hyper bus memory in MMIO mode.  <a href="group__group__smif__memnum.html#ga20bffdee7e2b8c7404b746b4b7de1f90">More...</a><br /></td></tr>
<tr class="separator:ga20bffdee7e2b8c7404b746b4b7de1f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bac26516695a4482496549816935808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__memnum.html#ga0bac26516695a4482496549816935808">Cy_SMIF_MemNumHyperBusWrite</a> (<a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *context, uint8_t memNum, uint32_t address, uint8_t const txBuffer[], uint32_t length)</td></tr>
<tr class="memdesc:ga0bac26516695a4482496549816935808"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes data into hyper bus memory in MMIO mode.  <a href="group__group__smif__memnum.html#ga0bac26516695a4482496549816935808">More...</a><br /></td></tr>
<tr class="separator:ga0bac26516695a4482496549816935808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structcy__stc__smif__mem__context__t" id="structcy__stc__smif__mem__context__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__smif__mem__context__t">&#9670;&nbsp;</a></span>cy_stc_smif_mem_context_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_smif_mem_context_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad9dfdbd8099b242d61acadf87d15e42e" name="ad9dfdbd8099b242d61acadf87d15e42e"></a>SMIF_Type *</td>
<td class="fieldname">
base</td>
<td class="fielddoc">
This stores the pointer to the base address of the SMIF instance. </td></tr>
<tr><td class="fieldtype">
<a id="a5a67a98ad7b6b65a7a508d79133d5f42" name="a5a67a98ad7b6b65a7a508d79133d5f42"></a><a class="el" href="group__group__smif__data__structures__memslot.html#structcy__stc__smif__block__config__t">cy_stc_smif_block_config_t</a> const  *</td>
<td class="fieldname">
block_config</td>
<td class="fielddoc">
This stores the pointer to the block config where applicable. </td></tr>
<tr><td class="fieldtype">
<a id="ae5b77476a68388be1f103dcb1a79a69d" name="ae5b77476a68388be1f103dcb1a79a69d"></a><a class="el" href="group__group__smif__data__structures.html#structcy__stc__smif__context__t">cy_stc_smif_context_t</a></td>
<td class="fieldname">
smif_context</td>
<td class="fielddoc">
This stores the info on the smif driver context. </td></tr>
<tr><td class="fieldtype">
<a id="aea47b37919174965f9b94857be952553" name="aea47b37919174965f9b94857be952553"></a>bool</td>
<td class="fieldname">
requires_secure_call</td>
<td class="fielddoc">
This specifies whether secure calls are needed. </td></tr>
</table>

</div>
</div>
<a name="structcy__stc__smif__hyb__sectors__info__t" id="structcy__stc__smif__hyb__sectors__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__smif__hyb__sectors__info__t">&#9670;&nbsp;</a></span>cy_stc_smif_hyb_sectors_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_smif_hyb_sectors_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a490e2c9395b4b79cddb2ed5f389722aa" name="a490e2c9395b4b79cddb2ed5f389722aa"></a>uint32_t</td>
<td class="fieldname">
regionStartAddress</td>
<td class="fielddoc">
This specifies the address where a region starts. </td></tr>
<tr><td class="fieldtype">
<a id="af5f18b2e1bcbd3f247036f44b889d29d" name="af5f18b2e1bcbd3f247036f44b889d29d"></a>uint32_t</td>
<td class="fieldname">
regionEndAddress</td>
<td class="fielddoc">
This specifies the address where a region ends <br  />
 </td></tr>
<tr><td class="fieldtype">
<a id="ac808229245d10ecb099d2a5054f879e2" name="ac808229245d10ecb099d2a5054f879e2"></a>uint32_t</td>
<td class="fieldname">
eraseSize</td>
<td class="fielddoc">
This specifies the erase size of one sector. </td></tr>
</table>

</div>
</div>
<a name="structcy__stc__smif__mem__info__t" id="structcy__stc__smif__mem__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structcy__stc__smif__mem__info__t">&#9670;&nbsp;</a></span>cy_stc_smif_mem_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct cy_stc_smif_mem_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a52555be31b9a6ec35194fbc5e8f5b951" name="a52555be31b9a6ec35194fbc5e8f5b951"></a>uint32_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
Determines if the device is SPI/HyperBus. </td></tr>
<tr><td class="fieldtype">
<a id="aeeac2b9bab45d08dfd1b120f9434b3d9" name="aeeac2b9bab45d08dfd1b120f9434b3d9"></a>uint32_t</td>
<td class="fieldname">
memSize</td>
<td class="fielddoc">
The memory size: For densities of 2 gigabits or less - the size in bytes; For densities 4 gigabits and above - bit-31 is set to 1b to define that this memory is 4 gigabits and above; and other 30:0 bits define N where the density is computed as 2^N bytes. <p >For example, 0x80000021 corresponds to 2^30 = 1 gigabyte. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7de4be9039994ace83c5af3b95f00393" name="a7de4be9039994ace83c5af3b95f00393"></a>uint32_t</td>
<td class="fieldname">
eraseSize</td>
<td class="fielddoc">
This specifies the sector size of each Erase. </td></tr>
<tr><td class="fieldtype">
<a id="a5f52e3f91c49965a4f3b8b9ae984f95e" name="a5f52e3f91c49965a4f3b8b9ae984f95e"></a>uint32_t</td>
<td class="fieldname">
programSize</td>
<td class="fielddoc">
This specifies the page size for programming. </td></tr>
<tr><td class="fieldtype">
<a id="aa2809cef402ba3349bdde718e87b7349" name="aa2809cef402ba3349bdde718e87b7349"></a>uint32_t</td>
<td class="fieldname">
hybridRegionCount</td>
<td class="fielddoc">
This specifies the number of regions for memory with hybrid sectors. </td></tr>
<tr><td class="fieldtype">
<a id="a4d606a619436cbb7e4ee8f32b41dce89" name="a4d606a619436cbb7e4ee8f32b41dce89"></a><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__hyb__sectors__info__t">cy_stc_smif_hyb_sectors_info_t</a></td>
<td class="fieldname">
hybridRegionInfo[<a class="el" href="group__group__smif__memnum.html#ga35b5de62ab95ba5d9e4123e7a0bc1cba">CY_SMIF_MAX_HYBRID_REGION</a>]</td>
<td class="fielddoc">
This stores the information for the hybrid regions. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga25c6d89bbe80347e2869ea4f9c7e3e3b" name="ga25c6d89bbe80347e2869ea4f9c7e3e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25c6d89bbe80347e2869ea4f9c7e3e3b">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumInit </td>
          <td>(</td>
          <td class="paramtype">SMIF_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__data__structures__memslot.html#structcy__stc__smif__block__config__t">cy_stc_smif_block_config_t</a> const *&#160;</td>
          <td class="paramname"><em>blockConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the slots of the memory device in the SMIF configuration. </p>
<p >It's security aware and is a thin wrapper around <a class="el" href="group__group__smif__mem__slot__functions.html#ga6f38cc37ab0e6fcb97d2675d1ae11771">Cy_SMIF_MemInit</a>. It can either be called in a secure partition or in the non-secure partition if the peripheral itself is not secured. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The address of the slave-slot device register to initialize.</td></tr>
    <tr><td class="paramname">blockConfig</td><td>The configuration structure array that configures the SMIF memory device to be mapped into the device's memory map. <a class="el" href="group__group__smif__data__structures__memslot.html#structcy__stc__smif__mem__config__t">cy_stc_smif_mem_config_t</a></td></tr>
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The memory slot initialization status.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41aab98f08cdd559a8220233078375b0319">CY_SMIF_SFDP_SS0_FAILED</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41ad03d666d999e6622e94873469908702b">CY_SMIF_SFDP_SS1_FAILED</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41ac7e1fa3b6e7239c7f349a6fb7f1bcffd">CY_SMIF_SFDP_SS2_FAILED</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a2cffe8c7a33af9216fa5d83f59ea769d">CY_SMIF_SFDP_SS3_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab4db2735b96e247a8181a9fb889160d1" name="gab4db2735b96e247a8181a9fb889160d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4db2735b96e247a8181a9fb889160d1">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumGetInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__info__t">cy_stc_smif_mem_info_t</a> *&#160;</td>
          <td class="paramname"><em>memNumInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is to be called from the non secure partition in trustzone devices to gather all information about the memory size, erase and program size to be used in subsequent MemNum calls instead of polling the secure partition repeatedly for the information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure. </td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to get information for. </td></tr>
    <tr><td class="paramname">memNumInfo</td><td>This is the pointer to the info structure ot type <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__info__t">cy_stc_smif_mem_info_t</a> to populate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The memory slot initialization status.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context and memNumInfo arguments are DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="ga7b8e79e0dac326c8c2bb3f9eaddf621e" name="ga7b8e79e0dac326c8c2bb3f9eaddf621e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8e79e0dac326c8c2bb3f9eaddf621e">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxBuffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from the external memory and blocks until the read transfer is complete or a timeout occurs. </p>
<p >This is a blocking function, it will block the execution flow until the command transmission is completed. It is security aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform read operation on.</td></tr>
    <tr><td class="paramname">address</td><td>The address to read data from. In case of Octal DDR, address must be an even address.</td></tr>
    <tr><td class="paramname">rxBuffer</td><td>The buffer for storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The size of data to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. See <a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context and rxBuffer arguments are DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="gaea43c03ea5b9d860dffb991888a929d4" name="gaea43c03ea5b9d860dffb991888a929d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea43c03ea5b9d860dffb991888a929d4">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>txBuffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes data to the external memory. </p>
<p >This is a blocking function, it will block the execution flow until the command transmission is completed. It is security aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform write operation on.</td></tr>
    <tr><td class="paramname">address</td><td>The address to write data at. In case of Octal DDR, address must be an even address.</td></tr>
    <tr><td class="paramname">txBuffer</td><td>The buffer holding the data to write in the external memory.</td></tr>
    <tr><td class="paramname">length</td><td>The size of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. See <a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context and txBuffer arguments are DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="ga5c213ddaa8165c67bb0b02bd3d2b9268" name="ga5c213ddaa8165c67bb0b02bd3d2b9268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c213ddaa8165c67bb0b02bd3d2b9268">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumEraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumEraseSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a block/sector of the external memory. </p>
<p >This is a blocking function, it will block the execution flow until the command transmission is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform erase sector operation on.</td></tr>
    <tr><td class="paramname">address</td><td>The address of the block to be erased. The address will be aligned to the start address of the sector in which address is located.</td></tr>
    <tr><td class="paramname">length</td><td>The length of data to erase. The length will be aligned to the sector boundary where end address is located. If length exceeds memory size API returns <a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> without performing erase operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. See <a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memories like hybrid have sectors of different sizes. <br  />
Check the address and length parameters before calling this function.</dd>
<dd>
This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context argument is DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="gafa64f50292063e65833c72f1deaf27f2" name="gafa64f50292063e65833c72f1deaf27f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa64f50292063e65833c72f1deaf27f2">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumEraseChip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumEraseChip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the entire chip of the external memory. </p>
<p >This is a blocking function, it will block the execution flow until the command transmission is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform erase sector operation on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. See <a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured and therefore the EraseChip function will not be run. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context argument is DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="ga20bffdee7e2b8c7404b746b4b7de1f90" name="ga20bffdee7e2b8c7404b746b4b7de1f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20bffdee7e2b8c7404b746b4b7de1f90">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumHyperBusRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumHyperBusRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxBuffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads data from hyper bus memory in MMIO mode. </p>
<p >It's security aware and is a thin wrapper around <a class="el" href="group__group__smif__mem__slot__functions.html#ga99c97b0a159196000873eebcfbf2edf8">Cy_SMIF_HyperBus_Read</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform read operation on.</td></tr>
    <tr><td class="paramname">address</td><td>The address to read data from. In case of Octal DDR, address must be an even address.</td></tr>
    <tr><td class="paramname">rxBuffer</td><td>The buffer for storing the read data.</td></tr>
    <tr><td class="paramname">length</td><td>The size of data to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context and rxBuffer arguments are DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
<a id="ga0bac26516695a4482496549816935808" name="ga0bac26516695a4482496549816935808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bac26516695a4482496549816935808">&#9670;&nbsp;</a></span>Cy_SMIF_MemNumHyperBusWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_MemNumHyperBusWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>txBuffer</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes data into hyper bus memory in MMIO mode. </p>
<p >It's security aware and is a thin wrapper around <a class="el" href="group__group__smif__mem__slot__functions.html#ga10e7768d340fa019ff3e791f8507fd59">Cy_SMIF_HyperBus_Write</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>This is the pointer to the context structure <a class="el" href="group__group__smif__memnum.html#structcy__stc__smif__mem__context__t">cy_stc_smif_mem_context_t</a> allocated by the user. The structure is used during the SMIF operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
    <tr><td class="paramname">memNum</td><td>The Slave Slot number associated to the memory in qspi-configurator to perform write operation on.</td></tr>
    <tr><td class="paramname">address</td><td>The address to write data at. In case of Octal DDR, address must be an even address.</td></tr>
    <tr><td class="paramname">txBuffer</td><td>The buffer holding the data to write in the external memory.</td></tr>
    <tr><td class="paramname">length</td><td>The size of data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is Secure Aware. On devices with ARM TrustZone enabled, it is safe to call on a Secure hardware resource from a Non-Secure CPU state. See <a class="el" href="group__group__smif__memnum.html#group_smif_section_secure_aware">Secure Aware SMIF</a> for further details. When determining whether an address range is accessible or not, there is a limitation that only XIP mapped addresses are considered. So if only a portion of the external memory is memory mapped, the remaining portion will be considered secured. The involved PPC regions are SMIF&lt;inst&gt;_CORE_MAIN, SMIF&lt;inst&gt;_CORE_CRYPTO, SMIF&lt;inst&gt;_CORE_MAIN2, and SMIF&lt;inst&gt;_CORE_DEVICE. These four regions must have the same security state.</dd>
<dd>
Ensure that context and txBuffer arguments are DCache aligned when calling from a non-secured Core onto a secured hardware resource. This is only relevent for cross-core calls, not calls between security contexts on the same core. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSOC E8XXGO Device Support Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
